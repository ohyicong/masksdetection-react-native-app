{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar RNFSManager = require('react-native').NativeModules.RNFSManager;\n\nvar NativeEventEmitter = require('react-native').NativeEventEmitter;\n\nvar RNFS_NativeEventEmitter = new NativeEventEmitter(RNFSManager);\n\nvar base64 = require('base-64');\n\nvar utf8 = require('utf8');\n\nvar isIOS = require('react-native').Platform.OS === 'ios';\nvar RNFSFileTypeRegular = RNFSManager.RNFSFileTypeRegular;\nvar RNFSFileTypeDirectory = RNFSManager.RNFSFileTypeDirectory;\nvar jobId = 0;\n\nvar getJobId = function getJobId() {\n  jobId += 1;\n  return jobId;\n};\n\nvar normalizeFilePath = function normalizeFilePath(path) {\n  return path.startsWith('file://') ? path.slice(7) : path;\n};\n\nfunction readFileGeneric(filepath, encodingOrOptions, command) {\n  var options = {\n    encoding: 'utf8'\n  };\n\n  if (encodingOrOptions) {\n    if (typeof encodingOrOptions === 'string') {\n      options.encoding = encodingOrOptions;\n    } else if (typeof encodingOrOptions === 'object') {\n      options = encodingOrOptions;\n    }\n  }\n\n  return command(normalizeFilePath(filepath)).then(function (b64) {\n    var contents;\n\n    if (options.encoding === 'utf8') {\n      contents = utf8.decode(base64.decode(b64));\n    } else if (options.encoding === 'ascii') {\n      contents = base64.decode(b64);\n    } else if (options.encoding === 'base64') {\n      contents = b64;\n    } else {\n      throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n    }\n\n    return contents;\n  });\n}\n\nfunction readDirGeneric(dirpath, command) {\n  return command(normalizeFilePath(dirpath)).then(function (files) {\n    return files.map(function (file) {\n      return {\n        ctime: file.ctime && new Date(file.ctime * 1000) || null,\n        mtime: file.mtime && new Date(file.mtime * 1000) || null,\n        name: file.name,\n        path: file.path,\n        size: file.size,\n        isFile: function isFile() {\n          return file.type === RNFSFileTypeRegular;\n        },\n        isDirectory: function isDirectory() {\n          return file.type === RNFSFileTypeDirectory;\n        }\n      };\n    });\n  });\n}\n\nvar RNFS = {\n  mkdir: function mkdir(filepath) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return RNFSManager.mkdir(normalizeFilePath(filepath), options).then(function () {\n      return void 0;\n    });\n  },\n  moveFile: function moveFile(filepath, destPath) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return RNFSManager.moveFile(normalizeFilePath(filepath), normalizeFilePath(destPath), options).then(function () {\n      return void 0;\n    });\n  },\n  copyFile: function copyFile(filepath, destPath) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return RNFSManager.copyFile(normalizeFilePath(filepath), normalizeFilePath(destPath), options).then(function () {\n      return void 0;\n    });\n  },\n  pathForBundle: function pathForBundle(bundleNamed) {\n    return RNFSManager.pathForBundle(bundleNamed);\n  },\n  pathForGroup: function pathForGroup(groupName) {\n    return RNFSManager.pathForGroup(groupName);\n  },\n  getFSInfo: function getFSInfo() {\n    return RNFSManager.getFSInfo();\n  },\n  getAllExternalFilesDirs: function getAllExternalFilesDirs() {\n    return RNFSManager.getAllExternalFilesDirs();\n  },\n  unlink: function unlink(filepath) {\n    return RNFSManager.unlink(normalizeFilePath(filepath)).then(function () {\n      return void 0;\n    });\n  },\n  exists: function exists(filepath) {\n    return RNFSManager.exists(normalizeFilePath(filepath));\n  },\n  stopDownload: function stopDownload(jobId) {\n    RNFSManager.stopDownload(jobId);\n  },\n  resumeDownload: function resumeDownload(jobId) {\n    RNFSManager.resumeDownload(jobId);\n  },\n  isResumable: function isResumable(jobId) {\n    return RNFSManager.isResumable(jobId);\n  },\n  stopUpload: function stopUpload(jobId) {\n    RNFSManager.stopUpload(jobId);\n  },\n  completeHandlerIOS: function completeHandlerIOS(jobId) {\n    return RNFSManager.completeHandlerIOS(jobId);\n  },\n  readDir: function readDir(dirpath) {\n    return readDirGeneric(dirpath, RNFSManager.readDir);\n  },\n  readDirAssets: function readDirAssets(dirpath) {\n    if (!RNFSManager.readDirAssets) {\n      throw new Error('readDirAssets is not available on this platform');\n    }\n\n    return readDirGeneric(dirpath, RNFSManager.readDirAssets);\n  },\n  existsAssets: function existsAssets(filepath) {\n    if (!RNFSManager.existsAssets) {\n      throw new Error('existsAssets is not available on this platform');\n    }\n\n    return RNFSManager.existsAssets(filepath);\n  },\n  existsRes: function existsRes(filename) {\n    if (!RNFSManager.existsRes) {\n      throw new Error('existsRes is not available on this platform');\n    }\n\n    return RNFSManager.existsRes(filename);\n  },\n  readdir: function readdir(dirpath) {\n    return RNFS.readDir(normalizeFilePath(dirpath)).then(function (files) {\n      return files.map(function (file) {\n        return file.name;\n      });\n    });\n  },\n  setReadable: function setReadable(filepath, readable, ownerOnly) {\n    return RNFSManager.setReadable(filepath, readable, ownerOnly).then(function (result) {\n      return result;\n    });\n  },\n  stat: function stat(filepath) {\n    return RNFSManager.stat(normalizeFilePath(filepath)).then(function (result) {\n      return {\n        'path': filepath,\n        'ctime': new Date(result.ctime * 1000),\n        'mtime': new Date(result.mtime * 1000),\n        'size': result.size,\n        'mode': result.mode,\n        'originalFilepath': result.originalFilepath,\n        isFile: function isFile() {\n          return result.type === RNFSFileTypeRegular;\n        },\n        isDirectory: function isDirectory() {\n          return result.type === RNFSFileTypeDirectory;\n        }\n      };\n    });\n  },\n  readFile: function readFile(filepath, encodingOrOptions) {\n    return readFileGeneric(filepath, encodingOrOptions, RNFSManager.readFile);\n  },\n  read: function read(filepath) {\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var encodingOrOptions = arguments.length > 3 ? arguments[3] : undefined;\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    return RNFSManager.read(normalizeFilePath(filepath), length, position).then(function (b64) {\n      var contents;\n\n      if (options.encoding === 'utf8') {\n        contents = utf8.decode(base64.decode(b64));\n      } else if (options.encoding === 'ascii') {\n        contents = base64.decode(b64);\n      } else if (options.encoding === 'base64') {\n        contents = b64;\n      } else {\n        throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n      }\n\n      return contents;\n    });\n  },\n  readFileAssets: function readFileAssets(filepath, encodingOrOptions) {\n    if (!RNFSManager.readFileAssets) {\n      throw new Error('readFileAssets is not available on this platform');\n    }\n\n    return readFileGeneric(filepath, encodingOrOptions, RNFSManager.readFileAssets);\n  },\n  readFileRes: function readFileRes(filename, encodingOrOptions) {\n    if (!RNFSManager.readFileRes) {\n      throw new Error('readFileRes is not available on this platform');\n    }\n\n    return readFileGeneric(filename, encodingOrOptions, RNFSManager.readFileRes);\n  },\n  hash: function hash(filepath, algorithm) {\n    return RNFSManager.hash(normalizeFilePath(filepath), algorithm);\n  },\n  copyFileAssets: function copyFileAssets(filepath, destPath) {\n    if (!RNFSManager.copyFileAssets) {\n      throw new Error('copyFileAssets is not available on this platform');\n    }\n\n    return RNFSManager.copyFileAssets(normalizeFilePath(filepath), normalizeFilePath(destPath)).then(function () {\n      return void 0;\n    });\n  },\n  copyFileRes: function copyFileRes(filename, destPath) {\n    if (!RNFSManager.copyFileRes) {\n      throw new Error('copyFileRes is not available on this platform');\n    }\n\n    return RNFSManager.copyFileRes(filename, normalizeFilePath(destPath)).then(function () {\n      return void 0;\n    });\n  },\n  copyAssetsFileIOS: function copyAssetsFileIOS(imageUri, destPath, width, height) {\n    var scale = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1.0;\n    var compression = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1.0;\n    var resizeMode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'contain';\n    return RNFSManager.copyAssetsFileIOS(imageUri, destPath, width, height, scale, compression, resizeMode);\n  },\n  copyAssetsVideoIOS: function copyAssetsVideoIOS(imageUri, destPath) {\n    return RNFSManager.copyAssetsVideoIOS(imageUri, destPath);\n  },\n  writeFile: function writeFile(filepath, contents, encodingOrOptions) {\n    var b64;\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = _objectSpread(_objectSpread({}, options), encodingOrOptions);\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.writeFile(normalizeFilePath(filepath), b64, options).then(function () {\n      return void 0;\n    });\n  },\n  appendFile: function appendFile(filepath, contents, encodingOrOptions) {\n    var b64;\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.appendFile(normalizeFilePath(filepath), b64);\n  },\n  write: function write(filepath, contents, position, encodingOrOptions) {\n    var b64;\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    if (position === undefined) {\n      position = -1;\n    }\n\n    return RNFSManager.write(normalizeFilePath(filepath), b64, position).then(function () {\n      return void 0;\n    });\n  },\n  downloadFile: function downloadFile(options) {\n    if (typeof options !== 'object') throw new Error('downloadFile: Invalid value for argument `options`');\n    if (typeof options.fromUrl !== 'string') throw new Error('downloadFile: Invalid value for property `fromUrl`');\n    if (typeof options.toFile !== 'string') throw new Error('downloadFile: Invalid value for property `toFile`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('downloadFile: Invalid value for property `headers`');\n    if (options.background && typeof options.background !== 'boolean') throw new Error('downloadFile: Invalid value for property `background`');\n    if (options.progressDivider && typeof options.progressDivider !== 'number') throw new Error('downloadFile: Invalid value for property `progressDivider`');\n    if (options.progressInterval && typeof options.progressInterval !== 'number') throw new Error('downloadFile: Invalid value for property `progressInterval`');\n    if (options.readTimeout && typeof options.readTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `readTimeout`');\n    if (options.connectionTimeout && typeof options.connectionTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `connectionTimeout`');\n    if (options.backgroundTimeout && typeof options.backgroundTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `backgroundTimeout`');\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (options.begin) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadBegin', function (res) {\n        if (res.jobId === jobId) options.begin(res);\n      }));\n    }\n\n    if (options.progress) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadProgress', function (res) {\n        if (res.jobId === jobId) options.progress(res);\n      }));\n    }\n\n    if (options.resumable) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadResumable', function (res) {\n        if (res.jobId === jobId) options.resumable(res);\n      }));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      fromUrl: options.fromUrl,\n      toFile: normalizeFilePath(options.toFile),\n      headers: options.headers || {},\n      background: !!options.background,\n      progressDivider: options.progressDivider || 0,\n      progressInterval: options.progressInterval || 0,\n      readTimeout: options.readTimeout || 15000,\n      connectionTimeout: options.connectionTimeout || 5000,\n      backgroundTimeout: options.backgroundTimeout || 3600000,\n      hasBeginCallback: options.begin instanceof Function,\n      hasProgressCallback: options.progress instanceof Function,\n      hasResumableCallback: options.resumable instanceof Function\n    };\n    return {\n      jobId: jobId,\n      promise: RNFSManager.downloadFile(bridgeOptions).then(function (res) {\n        subscriptions.forEach(function (sub) {\n          return sub.remove();\n        });\n        return res;\n      }).catch(function (e) {\n        return Promise.reject(e);\n      })\n    };\n  },\n  uploadFiles: function uploadFiles(options) {\n    if (!RNFSManager.uploadFiles) {\n      return {\n        jobId: -1,\n        promise: Promise.reject(new Error('`uploadFiles` is unsupported on this platform'))\n      };\n    }\n\n    var jobId = getJobId();\n    var subscriptions = [];\n    if (typeof options !== 'object') throw new Error('uploadFiles: Invalid value for argument `options`');\n    if (typeof options.toUrl !== 'string') throw new Error('uploadFiles: Invalid value for property `toUrl`');\n    if (!Array.isArray(options.files)) throw new Error('uploadFiles: Invalid value for property `files`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('uploadFiles: Invalid value for property `headers`');\n    if (options.fields && typeof options.fields !== 'object') throw new Error('uploadFiles: Invalid value for property `fields`');\n    if (options.method && typeof options.method !== 'string') throw new Error('uploadFiles: Invalid value for property `method`');\n\n    if (options.begin) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadBegin', options.begin));\n    } else if (options.beginCallback) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadBegin', options.beginCallback));\n    }\n\n    if (options.progress) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadProgress', options.progress));\n    } else if (options.progressCallback) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadProgress', options.progressCallback));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      toUrl: options.toUrl,\n      files: options.files,\n      binaryStreamOnly: options.binaryStreamOnly || false,\n      headers: options.headers || {},\n      fields: options.fields || {},\n      method: options.method || 'POST',\n      hasBeginCallback: options.begin instanceof Function || options.beginCallback instanceof Function,\n      hasProgressCallback: options.progress instanceof Function || options.progressCallback instanceof Function\n    };\n    return {\n      jobId: jobId,\n      promise: RNFSManager.uploadFiles(bridgeOptions).then(function (res) {\n        subscriptions.forEach(function (sub) {\n          return sub.remove();\n        });\n        return res;\n      })\n    };\n  },\n  touch: function touch(filepath, mtime, ctime) {\n    if (ctime && !(ctime instanceof Date)) throw new Error('touch: Invalid value for argument `ctime`');\n    if (mtime && !(mtime instanceof Date)) throw new Error('touch: Invalid value for argument `mtime`');\n    var ctimeTime = 0;\n\n    if (isIOS) {\n      ctimeTime = ctime && ctime.getTime();\n    }\n\n    return RNFSManager.touch(normalizeFilePath(filepath), mtime && mtime.getTime(), ctimeTime);\n  },\n  scanFile: function scanFile(path) {\n    return RNFSManager.scanFile(path);\n  },\n  MainBundlePath: RNFSManager.RNFSMainBundlePath,\n  CachesDirectoryPath: RNFSManager.RNFSCachesDirectoryPath,\n  ExternalCachesDirectoryPath: RNFSManager.RNFSExternalCachesDirectoryPath,\n  DocumentDirectoryPath: RNFSManager.RNFSDocumentDirectoryPath,\n  DownloadDirectoryPath: RNFSManager.RNFSDownloadDirectoryPath,\n  ExternalDirectoryPath: RNFSManager.RNFSExternalDirectoryPath,\n  ExternalStorageDirectoryPath: RNFSManager.RNFSExternalStorageDirectoryPath,\n  TemporaryDirectoryPath: RNFSManager.RNFSTemporaryDirectoryPath,\n  LibraryDirectoryPath: RNFSManager.RNFSLibraryDirectoryPath,\n  PicturesDirectoryPath: RNFSManager.RNFSPicturesDirectoryPath,\n  FileProtectionKeys: RNFSManager.RNFSFileProtectionKeys\n};\nmodule.exports = RNFS;","map":{"version":3,"sources":["C:/Users/OHyic/Desktop/react_native/ai-app/node_modules/react-native-fs/FS.common.js"],"names":["RNFSManager","require","NativeModules","NativeEventEmitter","RNFS_NativeEventEmitter","base64","utf8","isIOS","Platform","OS","RNFSFileTypeRegular","RNFSFileTypeDirectory","jobId","getJobId","normalizeFilePath","path","startsWith","slice","readFileGeneric","filepath","encodingOrOptions","command","options","encoding","then","b64","contents","decode","Error","String","readDirGeneric","dirpath","files","map","file","ctime","Date","mtime","name","size","isFile","type","isDirectory","RNFS","mkdir","moveFile","destPath","copyFile","pathForBundle","bundleNamed","pathForGroup","groupName","getFSInfo","getAllExternalFilesDirs","unlink","exists","stopDownload","resumeDownload","isResumable","stopUpload","completeHandlerIOS","readDir","readDirAssets","existsAssets","existsRes","filename","readdir","setReadable","readable","ownerOnly","result","stat","mode","originalFilepath","readFile","read","length","position","readFileAssets","readFileRes","hash","algorithm","copyFileAssets","copyFileRes","copyAssetsFileIOS","imageUri","width","height","scale","compression","resizeMode","copyAssetsVideoIOS","writeFile","encode","appendFile","write","undefined","downloadFile","fromUrl","toFile","headers","background","progressDivider","progressInterval","readTimeout","connectionTimeout","backgroundTimeout","subscriptions","begin","push","addListener","res","progress","resumable","bridgeOptions","hasBeginCallback","Function","hasProgressCallback","hasResumableCallback","promise","forEach","sub","remove","catch","e","Promise","reject","uploadFiles","toUrl","Array","isArray","fields","method","beginCallback","progressCallback","binaryStreamOnly","touch","ctimeTime","getTime","scanFile","MainBundlePath","RNFSMainBundlePath","CachesDirectoryPath","RNFSCachesDirectoryPath","ExternalCachesDirectoryPath","RNFSExternalCachesDirectoryPath","DocumentDirectoryPath","RNFSDocumentDirectoryPath","DownloadDirectoryPath","RNFSDownloadDirectoryPath","ExternalDirectoryPath","RNFSExternalDirectoryPath","ExternalStorageDirectoryPath","RNFSExternalStorageDirectoryPath","TemporaryDirectoryPath","RNFSTemporaryDirectoryPath","LibraryDirectoryPath","RNFSLibraryDirectoryPath","PicturesDirectoryPath","RNFSPicturesDirectoryPath","FileProtectionKeys","RNFSFileProtectionKeys","module","exports"],"mappings":"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","sourcesContent":["/**\n * React Native FS\n * @flow\n */\n\n'use strict';\n\n// This file supports both iOS and Android\n\nvar RNFSManager = require('react-native').NativeModules.RNFSManager;\n\nvar NativeEventEmitter = require('react-native').NativeEventEmitter;\n\nvar RNFS_NativeEventEmitter = new NativeEventEmitter(RNFSManager);\n\nvar base64 = require('base-64');\nvar utf8 = require('utf8');\nvar isIOS = require('react-native').Platform.OS === 'ios';\n\nvar RNFSFileTypeRegular = RNFSManager.RNFSFileTypeRegular;\nvar RNFSFileTypeDirectory = RNFSManager.RNFSFileTypeDirectory;\n\nvar jobId = 0;\n\nvar getJobId = () => {\n  jobId += 1;\n  return jobId;\n};\n\nvar normalizeFilePath = (path: string) => (path.startsWith('file://') ? path.slice(7) : path);\n\ntype MkdirOptions = {\n  NSURLIsExcludedFromBackupKey?: boolean; // iOS only\n  NSFileProtectionKey?: string; // IOS only\n};\n\ntype FileOptions = {\n  NSFileProtectionKey?: string; // IOS only\n};\n\ntype ReadDirItem = {\n  ctime: ?Date;    // The creation date of the file (iOS only)\n  mtime: ?Date;    // The last modified date of the file\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n\ntype StatResult = {\n  name: ?string;     // The name of the item TODO: why is this not documented?\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  mode: number;     // UNIX file mode\n  ctime: number;    // Created date\n  mtime: number;    // Last modified date\n  originalFilepath: string;    // In case of content uri this is the pointed file path, otherwise is the same as path\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n\ntype Headers = { [name: string]: string };\ntype Fields = { [name: string]: string };\n\ntype DownloadFileOptions = {\n  fromUrl: string;          // URL to download file from\n  toFile: string;           // Local filesystem path to save the file to\n  headers?: Headers;        // An object of headers to be passed to the server\n  background?: boolean;     // Continue the download in the background after the app terminates (iOS only)\n  discretionary?: boolean;  // Allow the OS to control the timing and speed of the download to improve perceived performance  (iOS only)\n  cacheable?: boolean;      // Whether the download can be stored in the shared NSURLCache (iOS only)\n  progressInterval?: number;\n  progressDivider?: number;\n  begin?: (res: DownloadBeginCallbackResult) => void;\n  progress?: (res: DownloadProgressCallbackResult) => void;\n  resumable?: () => void;    // only supported on iOS yet\n  connectionTimeout?: number; // only supported on Android yet\n  readTimeout?: number;       // supported on Android and iOS\n  backgroundTimeout?: number; // Maximum time (in milliseconds) to download an entire resource (iOS only, useful for timing out background downloads)\n};\n\ntype DownloadBeginCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  contentLength: number;  // The total size in bytes of the download resource\n  headers: Headers;       // The HTTP response headers from the server\n};\n\ntype DownloadProgressCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  contentLength: number;  // The total size in bytes of the download resource\n  bytesWritten: number;   // The number of bytes written to the file so far\n};\n\ntype DownloadResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  bytesWritten: number;   // The number of bytes written to the file\n};\n\ntype UploadFileOptions = {\n  toUrl: string;            // URL to upload file to\n  binaryStreamOnly?: boolean; // Allow for binary data stream for file to be uploaded without extra headers, Default is 'false'\n  files: UploadFileItem[];  // An array of objects with the file information to be uploaded.\n  headers?: Headers;        // An object of headers to be passed to the server\n  fields?: Fields;          // An object of fields to be passed to the server\n  method?: string;          // Default is 'POST', supports 'POST' and 'PUT'\n  beginCallback?: (res: UploadBeginCallbackResult) => void; // deprecated\n  progressCallback?: (res: UploadProgressCallbackResult) => void; // deprecated\n  begin?: (res: UploadBeginCallbackResult) => void;\n  progress?: (res: UploadProgressCallbackResult) => void;\n};\n\ntype UploadFileItem = {\n  name: string;       // Name of the file, if not defined then filename is used\n  filename: string;   // Name of file\n  filepath: string;   // Path to file\n  filetype: string;   // The mimetype of the file to be uploaded, if not defined it will get mimetype from `filepath` extension\n};\n\ntype UploadBeginCallbackResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n};\n\ntype UploadProgressCallbackResult = {\n  jobId: number;                      // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  totalBytesExpectedToSend: number;   // The total number of bytes that will be sent to the server\n  totalBytesSent: number;             // The number of bytes sent to the server\n};\n\ntype UploadResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  statusCode: number;   // The HTTP status code\n  headers: Headers;     // The HTTP response headers from the server\n  body: string;         // The HTTP response body\n};\n\ntype FSInfoResult = {\n  totalSpace: number;   // The total amount of storage space on the device (in bytes).\n  freeSpace: number;    // The amount of available storage space on the device (in bytes).\n};\n\n/**\n * Generic function used by readFile and readFileAssets\n */\nfunction readFileGeneric(filepath: string, encodingOrOptions: ?string, command: Function) {\n  var options = {\n    encoding: 'utf8'\n  };\n\n  if (encodingOrOptions) {\n    if (typeof encodingOrOptions === 'string') {\n      options.encoding = encodingOrOptions;\n    } else if (typeof encodingOrOptions === 'object') {\n      options = encodingOrOptions;\n    }\n  }\n\n  return command(normalizeFilePath(filepath)).then((b64) => {\n    var contents;\n\n    if (options.encoding === 'utf8') {\n      contents = utf8.decode(base64.decode(b64));\n    } else if (options.encoding === 'ascii') {\n      contents = base64.decode(b64);\n    } else if (options.encoding === 'base64') {\n      contents = b64;\n    } else {\n      throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n    }\n\n    return contents;\n  });\n}\n\n/**\n * Generic function used by readDir and readDirAssets\n */\nfunction readDirGeneric(dirpath: string, command: Function) {\n  return command(normalizeFilePath(dirpath)).then(files => {\n    return files.map(file => ({\n      ctime: file.ctime && new Date(file.ctime * 1000) || null,\n      mtime: file.mtime && new Date(file.mtime * 1000) || null,\n      name: file.name,\n      path: file.path,\n      size: file.size,\n      isFile: () => file.type === RNFSFileTypeRegular,\n      isDirectory: () => file.type === RNFSFileTypeDirectory,\n    }));\n  });\n}\n\nvar RNFS = {\n\n  mkdir(filepath: string, options: MkdirOptions = {}): Promise<void> {\n    return RNFSManager.mkdir(normalizeFilePath(filepath), options).then(() => void 0);\n  },\n\n  moveFile(filepath: string, destPath: string, options: FileOptions = {}): Promise<void> {\n    return RNFSManager.moveFile(normalizeFilePath(filepath), normalizeFilePath(destPath), options).then(() => void 0);\n  },\n\n  copyFile(filepath: string, destPath: string, options: FileOptions = {}): Promise<void> {\n    return RNFSManager.copyFile(normalizeFilePath(filepath), normalizeFilePath(destPath), options).then(() => void 0);\n  },\n\n  pathForBundle(bundleNamed: string): Promise<string> {\n    return RNFSManager.pathForBundle(bundleNamed);\n  },\n\n  pathForGroup(groupName: string): Promise<string> {\n    return RNFSManager.pathForGroup(groupName);\n  },\n\n  getFSInfo(): Promise<FSInfoResult> {\n    return RNFSManager.getFSInfo();\n  },\n\n  getAllExternalFilesDirs(): Promise<string> {\n    return RNFSManager.getAllExternalFilesDirs();\n  },\n\n  unlink(filepath: string): Promise<void> {\n    return RNFSManager.unlink(normalizeFilePath(filepath)).then(() => void 0);\n  },\n\n  exists(filepath: string): Promise<boolean> {\n    return RNFSManager.exists(normalizeFilePath(filepath));\n  },\n\n  stopDownload(jobId: number): void {\n    RNFSManager.stopDownload(jobId);\n  },\n\n  resumeDownload(jobId: number): void {\n    RNFSManager.resumeDownload(jobId);\n  },\n\n  isResumable(jobId: number): Promise<bool> {\n    return RNFSManager.isResumable(jobId);\n  },\n\n  stopUpload(jobId: number): void {\n    RNFSManager.stopUpload(jobId);\n  },\n\n  completeHandlerIOS(jobId: number): void {\n    return RNFSManager.completeHandlerIOS(jobId);\n  },\n\n  readDir(dirpath: string): Promise<ReadDirItem[]> {\n    return readDirGeneric(dirpath, RNFSManager.readDir);\n  },\n\n  // Android-only\n  readDirAssets(dirpath: string): Promise<ReadDirItem[]> {\n    if (!RNFSManager.readDirAssets) {\n      throw new Error('readDirAssets is not available on this platform');\n    }\n    return readDirGeneric(dirpath, RNFSManager.readDirAssets);\n  },\n\n  // Android-only\n  existsAssets(filepath: string) {\n    if (!RNFSManager.existsAssets) {\n      throw new Error('existsAssets is not available on this platform');\n    }\n    return RNFSManager.existsAssets(filepath);\n  },\n\n  // Android-only\n  existsRes(filename: string) {\n    if (!RNFSManager.existsRes) {\n      throw new Error('existsRes is not available on this platform');\n    }\n    return RNFSManager.existsRes(filename);\n  },\n\n  // Node style version (lowercase d). Returns just the names\n  readdir(dirpath: string): Promise<string[]> {\n    return RNFS.readDir(normalizeFilePath(dirpath)).then(files => {\n      return files.map(file => file.name);\n    });\n  },\n\n  // setReadable for Android\n  setReadable(filepath: string, readable: boolean, ownerOnly: boolean): Promise<boolean> {\n    return RNFSManager.setReadable(filepath, readable, ownerOnly).then((result) => {\n      return result;\n    })\n  },\n\n  stat(filepath: string): Promise<StatResult> {\n    return RNFSManager.stat(normalizeFilePath(filepath)).then((result) => {\n      return {\n        'path': filepath,\n        'ctime': new Date(result.ctime * 1000),\n        'mtime': new Date(result.mtime * 1000),\n        'size': result.size,\n        'mode': result.mode,\n        'originalFilepath': result.originalFilepath,\n        isFile: () => result.type === RNFSFileTypeRegular,\n        isDirectory: () => result.type === RNFSFileTypeDirectory,\n      };\n    });\n  },\n\n  readFile(filepath: string, encodingOrOptions?: any): Promise<string> {\n    return readFileGeneric(filepath, encodingOrOptions, RNFSManager.readFile);\n  },\n\n  read(filepath: string, length: number = 0, position: number = 0, encodingOrOptions?: any): Promise<string> {\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    return RNFSManager.read(normalizeFilePath(filepath), length, position).then((b64) => {\n      var contents;\n\n      if (options.encoding === 'utf8') {\n        contents = utf8.decode(base64.decode(b64));\n      } else if (options.encoding === 'ascii') {\n        contents = base64.decode(b64);\n      } else if (options.encoding === 'base64') {\n        contents = b64;\n      } else {\n        throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n      }\n\n      return contents;\n    });\n  },\n\n  // Android only\n  readFileAssets(filepath: string, encodingOrOptions?: any): Promise<string> {\n    if (!RNFSManager.readFileAssets) {\n      throw new Error('readFileAssets is not available on this platform');\n    }\n    return readFileGeneric(filepath, encodingOrOptions, RNFSManager.readFileAssets);\n  },\n\n  // Android only\n  readFileRes(filename: string, encodingOrOptions?: any): Promise<string> {\n    if (!RNFSManager.readFileRes) {\n      throw new Error('readFileRes is not available on this platform');\n    }\n    return readFileGeneric(filename, encodingOrOptions, RNFSManager.readFileRes);\n  },\n\n  hash(filepath: string, algorithm: string): Promise<string> {\n    return RNFSManager.hash(normalizeFilePath(filepath), algorithm);\n  },\n\n  // Android only\n  copyFileAssets(filepath: string, destPath: string) {\n    if (!RNFSManager.copyFileAssets) {\n      throw new Error('copyFileAssets is not available on this platform');\n    }\n    return RNFSManager.copyFileAssets(normalizeFilePath(filepath), normalizeFilePath(destPath)).then(() => void 0);\n  },\n\n  // Android only\n  copyFileRes(filename: string, destPath: string) {\n    if (!RNFSManager.copyFileRes) {\n      throw new Error('copyFileRes is not available on this platform');\n    }\n    return RNFSManager.copyFileRes(filename, normalizeFilePath(destPath)).then(() => void 0);\n  },\n\n  // iOS only\n  // Copies fotos from asset-library (camera-roll) to a specific location\n  // with a given width or height\n  // @see: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\n  copyAssetsFileIOS(imageUri: string, destPath: string, width: number, height: number,\n    scale: number = 1.0, compression: number = 1.0, resizeMode: string = 'contain'): Promise<string> {\n    return RNFSManager.copyAssetsFileIOS(imageUri, destPath, width, height, scale, compression, resizeMode);\n  },\n\n  // iOS only\n  // Copies fotos from asset-library (camera-roll) to a specific location\n  // with a given width or height\n  // @see: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\n  copyAssetsVideoIOS(imageUri: string, destPath: string): Promise<string> {\n    return RNFSManager.copyAssetsVideoIOS(imageUri, destPath);\n  },\n\n  writeFile(filepath: string, contents: string, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = {\n          ...options,\n          ...encodingOrOptions\n        };\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.writeFile(normalizeFilePath(filepath), b64, options).then(() => void 0);\n  },\n\n  appendFile(filepath: string, contents: string, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.appendFile(normalizeFilePath(filepath), b64);\n  },\n\n  write(filepath: string, contents: string, position?: number, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    if (position === undefined) {\n      position = -1;\n    }\n\n    return RNFSManager.write(normalizeFilePath(filepath), b64, position).then(() => void 0);\n  },\n\n  downloadFile(options: DownloadFileOptions): { jobId: number, promise: Promise<DownloadResult> } {\n    if (typeof options !== 'object') throw new Error('downloadFile: Invalid value for argument `options`');\n    if (typeof options.fromUrl !== 'string') throw new Error('downloadFile: Invalid value for property `fromUrl`');\n    if (typeof options.toFile !== 'string') throw new Error('downloadFile: Invalid value for property `toFile`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('downloadFile: Invalid value for property `headers`');\n    if (options.background && typeof options.background !== 'boolean') throw new Error('downloadFile: Invalid value for property `background`');\n    if (options.progressDivider && typeof options.progressDivider !== 'number') throw new Error('downloadFile: Invalid value for property `progressDivider`');\n    if (options.progressInterval && typeof options.progressInterval !== 'number') throw new Error('downloadFile: Invalid value for property `progressInterval`');\n    if (options.readTimeout && typeof options.readTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `readTimeout`');\n    if (options.connectionTimeout && typeof options.connectionTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `connectionTimeout`');\n    if (options.backgroundTimeout && typeof options.backgroundTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `backgroundTimeout`');\n\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (options.begin) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadBegin', (res) => {\n        if (res.jobId === jobId) options.begin(res);\n      }));\n    }\n\n    if (options.progress) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadProgress', (res) => {\n        if (res.jobId === jobId) options.progress(res);\n      }));\n    }\n\n    if (options.resumable) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadResumable', (res) => {\n        if (res.jobId === jobId) options.resumable(res);\n      }));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      fromUrl: options.fromUrl,\n      toFile: normalizeFilePath(options.toFile),\n      headers: options.headers || {},\n      background: !!options.background,\n      progressDivider: options.progressDivider || 0,\n      progressInterval: options.progressInterval || 0,\n      readTimeout: options.readTimeout || 15000,\n      connectionTimeout: options.connectionTimeout || 5000,\n      backgroundTimeout: options.backgroundTimeout || 3600000, // 1 hour\n      hasBeginCallback: options.begin instanceof Function,\n      hasProgressCallback: options.progress instanceof Function,\n      hasResumableCallback: options.resumable instanceof Function,\n    };\n\n    return {\n      jobId,\n      promise: RNFSManager.downloadFile(bridgeOptions).then(res => {\n        subscriptions.forEach(sub => sub.remove());\n        return res;\n      })\n        .catch(e => {\n          return Promise.reject(e);\n        })\n    };\n  },\n\n  uploadFiles(options: UploadFileOptions): { jobId: number, promise: Promise<UploadResult> } {\n    if (!RNFSManager.uploadFiles) {\n      return {\n        jobId: -1,\n        promise: Promise.reject(new Error('`uploadFiles` is unsupported on this platform'))\n      };\n    }\n\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (typeof options !== 'object') throw new Error('uploadFiles: Invalid value for argument `options`');\n    if (typeof options.toUrl !== 'string') throw new Error('uploadFiles: Invalid value for property `toUrl`');\n    if (!Array.isArray(options.files)) throw new Error('uploadFiles: Invalid value for property `files`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('uploadFiles: Invalid value for property `headers`');\n    if (options.fields && typeof options.fields !== 'object') throw new Error('uploadFiles: Invalid value for property `fields`');\n    if (options.method && typeof options.method !== 'string') throw new Error('uploadFiles: Invalid value for property `method`');\n\n    if (options.begin) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadBegin', options.begin));\n    } else if (options.beginCallback) {\n      // Deprecated\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadBegin', options.beginCallback));\n    }\n\n    if (options.progress) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadProgress', options.progress));\n    } else if (options.progressCallback) {\n      // Deprecated\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadProgress', options.progressCallback));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      toUrl: options.toUrl,\n      files: options.files,\n      binaryStreamOnly: options.binaryStreamOnly || false,\n      headers: options.headers || {},\n      fields: options.fields || {},\n      method: options.method || 'POST',\n      hasBeginCallback: options.begin instanceof Function || options.beginCallback instanceof Function,\n      hasProgressCallback: options.progress instanceof Function || options.progressCallback instanceof Function,\n    };\n\n    return {\n      jobId,\n      promise: RNFSManager.uploadFiles(bridgeOptions).then(res => {\n        subscriptions.forEach(sub => sub.remove());\n        return res;\n      })\n    };\n  },\n\n  touch(filepath: string, mtime?: Date, ctime?: Date): Promise<void> {\n    if (ctime && !(ctime instanceof Date)) throw new Error('touch: Invalid value for argument `ctime`');\n    if (mtime && !(mtime instanceof Date)) throw new Error('touch: Invalid value for argument `mtime`');\n    var ctimeTime = 0;\n    if (isIOS) {\n      ctimeTime = ctime && ctime.getTime();\n    }\n    return RNFSManager.touch(\n      normalizeFilePath(filepath),\n      mtime && mtime.getTime(),\n      ctimeTime\n    );\n  },\n\n  scanFile(path: string): Promise<ReadDirItem[]> {\n    return RNFSManager.scanFile(path);\n  },\n\n  MainBundlePath: RNFSManager.RNFSMainBundlePath,\n  CachesDirectoryPath: RNFSManager.RNFSCachesDirectoryPath,\n  ExternalCachesDirectoryPath: RNFSManager.RNFSExternalCachesDirectoryPath,\n  DocumentDirectoryPath: RNFSManager.RNFSDocumentDirectoryPath,\n  DownloadDirectoryPath: RNFSManager.RNFSDownloadDirectoryPath,\n  ExternalDirectoryPath: RNFSManager.RNFSExternalDirectoryPath,\n  ExternalStorageDirectoryPath: RNFSManager.RNFSExternalStorageDirectoryPath,\n  TemporaryDirectoryPath: RNFSManager.RNFSTemporaryDirectoryPath,\n  LibraryDirectoryPath: RNFSManager.RNFSLibraryDirectoryPath,\n  PicturesDirectoryPath: RNFSManager.RNFSPicturesDirectoryPath,\n  FileProtectionKeys: RNFSManager.RNFSFileProtectionKeys\n};\n\nmodule.exports = RNFS;\n"]},"metadata":{},"sourceType":"script"}